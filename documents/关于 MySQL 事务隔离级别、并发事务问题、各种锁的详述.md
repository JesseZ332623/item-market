# 关于 MySQL 事务隔离级别、并发事务问题、各种锁的详述

## 3 个事务并发带来的经典问题

### 1. 脏读

一个事务（A）读取到了另一个尚未提交事务（B）修改过的数据，
事务 B 可能会**回滚**，若事务 B 真的回滚了，
那么 A 读到的就是无效、错误、不存在与数据库中的 “脏” 数据。

### 2. 不可重复读

在同一个事务（A）内，两次读取同一行数据，
因为在事务 A 两次读取同一行数据期间，事务 B 对这行数据做出了修改并提交，
导致事务 A 的两次读取得到的结果不相同。

### 3. 幻读

在同一个事务（A）内， 执行两次完全相同地查询（通常是 WHERE 范围查询），得到了不同的结果集合。
原因是两次查询期间，另一个事务（B）提交了带有插入（INSERT）或删除（DELETE）操作的事务，
导致满足查询条件的行出现了变化。

## MySQL InnoDB 引擎的锁类型

## 按操作权限分类

### 1. 共享锁（S）

在使用形如 `SELECT ... FOR SHARE` 语句读取某一行时上该锁，
它允许其他的事务也加共享锁读取同一行，但不允许其他事务加排他锁修改这一行。

### 2. 排他锁（X）

在使用形如 `SELECT ... FOR UPDATE` `UPDATE` `DELETE` `INSERT` 语句修改某一行时加上该锁，
它不允许其他事务对上锁的这个行加上任何类型的锁（S 或者 X）读取或修改该行。

## 按作用范围（锁的颗粒度）分类

### 1. 意向锁（Intention Locks - 表级锁）

- 意向共享锁（IS）表示事务打算在表中的某些行上加共享锁
- 意向排他锁（IX）表示事务打算在表中的某些行上加排他锁

IS 和 IX 可以提高效率，当另一个事务想在表上加表级锁（使用 `LOCK TABLE ... WRITE`）时，
通过检查该表的意向锁就能快速知道是否有行锁冲突，无需逐行检查。

- **意向锁工作流程示例**

    - 事务 A 在修改数据表的某行数据前，先在整张表上加意向排他锁（IX），
      再在要修改的行加上排他锁（X），然后执行数据的修改。
  
    - 紧接着，事务 B 开始运行，
      它想使用 `LOCK TABLE ... WRITE`（表级别排他锁）锁住整张表，
      在此之前它会检查：
        - 表级意向排他锁和表级排他锁是否冲突，
          在本例中事务 A 已经上了表级意向排他锁，与事务 B 想上的表级排他锁冲突。

    - 因此，事务 B 会阻塞，等待事务 A 完成修改操作释放掉表级意向排他锁之后，
      才能为该表加上表级排他锁，正式的开始执行事务 B。
  

#### S, X, IS, IX 之间的相容矩阵（✅ 相容，❌ 冲突）

|    | X | IX | S | IS |
|----|---|----|---|----|
| X  | ❌ | ❌  | ❌ | ❌  |
| IX | ❌ | ✅  | ❌ | ✅  |
| S  | ❌ | ❌  | ✅ | ✅  |
| IS | ❌ | ✅  | ✅ | ✅  |

### 2. 行级锁（Record Locks）

它负责锁住索引记录本身，
防止其他事务修改或删除（通过 X）或者某些情况下读取（通过 X 阻止 S）该特定行。

### 3. 间隙锁（Gap Locks）

它负责锁住索引记录之间的间隙，或者第一个索引记录之前，最后一个索引记录之后的间隙，
防止其他事务在间隙中插入或删除，从而防止幻读。

还需要补充几点：

- 多个事务间可以在同一个间隙上加间隙锁。
- 间隙锁基于索引，若 SQL 语句没有用到索引，该锁就会退化为表级锁。

### 4. 临键锁（Next-Key Locks）

InnoDB 引擎特有的锁，组合行级锁和间隙锁，
旨在解决 REPETABLE READ 隔离等级下的幻读问题（核心机制）。

它负责锁住索引记录本身以及该记录之前的间隙。
假设索引值有 [10, 20, 30]，
那么临键锁的可能的区间为：(-inf, 10], (10, 20], (20, 30], (30, +inf]。

因此，当执行 `SELECT ... FOR UPDATE` 或 `UPDATE` / `DELETE` 一个范围时，
InnoDB 会对扫描到的索引记录及其间隙加上临键锁，组织其他事务在这个范围内插入新地记录或修改边界记录。

## MySQL 的 4 个事务隔离级别

### 读未提交（READ UNCOMMITED）
    
- 实现：读操作不加锁，写操作加排他锁（X）
- 缺陷：由于读操作不加锁，因此可能读到其他事务还未提交的修改（脏读），
        同一事务两次读取结果不一致（不可重复读）或者同一事务读取行数不一致（幻读）。

### 读已提交（READ COMMITED）

- 实现：

  - 快照读（普通的 `SELECT` 语句）：
    使用 MVCC (Multi-Version Concurrency Control)，
    每一次 SELECT 都会生成一个新的 Read View（一致性视图），读取已提交的、最新版本的数据。
    这避免了脏读，但是同一个事务内的两次相同的快照读可能读到不相同的数据（不可重复读），
    也可能看到其他事务新提交的插入数据（幻读）。
  
  - 当前读（`SELECT ... FOR UPDATE`, `UPDATE`, `DELETE`）
    只加行级锁，不加间隙锁，事务提交后立刻释放锁（不遵守两阶段协议）。
    这也避免了脏读（和快照读的一致性视图机制不同，由于行级排他锁的存在，读操作在写操作完成之前被阻塞），
    但还是避免不了不可重复读，比如同一事务内的当前读，
    如果两次读取之间其他事务提交了对该行的修改，第二次读会读到新值
    也避免不了幻读，比如范围查询时，只锁住扫描到的现有行，不锁间隙。
    其他事务可以在间隙中插入新行并提交。同一个事务内再次执行相同的范围查询，会看到新插入的行。


- 缺陷：避免了脏读，但是仍会发送不可重复读和幻读。

### 可重复读（REPETABLE READ - MySQL 默认的事务隔离等级）

- 实现：

    - 快照读（普通的 `SELECT` 语句）：
      和 READ COMMITED 一样使用 MVCC，不过只在事务第一次执行 `SELECT` 的时候生成 Read View，
      此后的所有该事务的快照读都使用这个 Read View。
      因此，在这个隔离等级下的快照读看到的是事务开始时的数据快照，避免了不可重复读和幻读。

    - 当前读（`SELECT ... FOR UPDATE`, `UPDATE`, `DELETE`）
      使用临键锁，锁住扫描到的记录和前面的间隙，分为下面几种情况：
  
      - `UPDATE` / `DELETE`：对 WHERE 条件的现有行加临键锁（X 模式的临键锁）。
      
      - `SELECT ... FOR UPDATE`：对 WHERE 条件的现有行加临键锁（S 模式的临键锁）。
      
      - `INSERT`：检查插入意向锁（一种特殊的间隙锁）是否与已有的间隙锁或临键锁冲突。

      
- 结论：

    当前读使用临键锁对记录和间隙上锁，
    阻止了其他事务在锁定范围内插入新记录，或修改边界记录导致部分结果移出范围（有效避免幻读）。
    同时，因为锁住了记录本身，也防止了不可重复读（其他事务无法删除或修改这些被锁定的行）。

### 串行化（SERIALIZABLE）

- 实现：所有普通的 `SELECT` 语句都会隐式的转换为 `SELECT ... FOR SHARE`。
        这意味着所有的读操作都会加共享锁（S），此外写操作也会加排他锁（X），
        这强制了事务间串行的执行，彻底的避免了脏读、不可重复读、和幻读。


- 缺陷：完全串行的执行事务，虽然避免了所有并发问题，但性能极差，不可能用于生产环境。

## MySQL 不同事务隔离级别可能会产生的并发问题汇总表：

- 图例（✅ 可能发生，❌ 不会发生）

|      并发问题 / 隔离等级      | 脏读（Dirty Read） | 不可重复读（Non-Repeatable Read） | 幻读（Phanton Read） |                   
|:---------------------:|:--------------:|:--------------------------:|:----------------:|
| 读未提交（READ UNCOMMITED） |       ✅        |             ✅              |        ✅         |                   
|  读已提交（READ COMMITED）  |       ❌        |             ✅              |        ✅         |                   
| 可重复读（REPETABLE READ）  |       ❌        |             ❌              |        ❌         |                   
|   串行化（SERIALIZABLE）   |       ❌        |             ❌              |        ❌         |

- Tips：MySQL 的 REPEATABLE READ 通过其独特的实现（Next-Key Locking + MVCC）有效地避免了幻读，
  这比 SQL 标准（理论上允许出现幻读）的要求更高。
